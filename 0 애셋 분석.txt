ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
기본 사용 방법
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

컴포넌트의 모든 요소를 다 배울 필요는 없고 이것저것 생각나는대로 시도해보면서 모르면 그떄 찾아보거나 기능확장을 고민해도 된다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
유니티 스탠다드 캐릭터 컨트롤러
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

머터리얼을 단순히 Standard 로 교체해주는것만으로 파이프라인 안맞는 문제가 해결되었다.

캐릭터 컨트롤러 기반, 충분히 쓸만하지만 리지드바디 솔루션은 최악이었음.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
인벡터
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

리지드바디 Velocity 기반

Roll 동작은 애니메이터 RootMotion 의 이동위치를 이전 프레임과 비교하여 Velocity 형태로 바꿔서 적용해주는것같음

V Animator Tag Advanced 를 이용하여 애니메이션 NormalziedTime 을 세부적으로 조정 가능


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ABC 툴킷
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Topdown, FPS 등등의 탬플릿을 Enable / Disalbe 하는것으로 사용가능

CurrentHealth 는 Ingegration 여부에 따라 다른 값을 리턴, 기본은 ABC Health

Stat 의 Adjust Value 는 값을 +50 하거나 -50 할때 쓰는것, 특정 값으로 설정하려면 SetValue

캐릭터 컨트롤러 + New Input System 기반

GC1 인티그레이션은 큰 쓸모가 없었다


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
코기 엔진
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Override 를 통해서 기능을 확장할 수 있었다.

Surface Crawler 와 Corgi Character Controller 를 같이 쓰려면 모든 인스펙터 변수를 0으로 설정해 움직임이 없도록 하면된다.

Grab Carry And Throw 를 위해선 Rigidbody 필요, 캐릭터가 들고있는 오브젝트를 벽위에 놓을경우 끼어버린다. 그래서 최대한 캐릭터 머리위에 위치하게 해야하는듯.

Health 만 있는 캐릭터의 경우 MMFeedback 으로 죽었을때 이것저것 코드를 쉽게 작성할 수 있다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
유니티 2D 게임 킷
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Platform 이펙트를 이용할때 해당 이펙터의 레이어를 플레이와 충돌하지 않도록 바꾸어 구현했다.

겉의 블록에만 타일맵 콜라이더를 심어서 맵을 만드는 방법도 있다. 이떄 맵은 가장자리 블록들이 비어있는걸로 보일 수 있으니 눌러서 확인할것.

Cinemachie 카메라에는 내 캐릭터 위치 / 목표 타겟 위치를 슬라이더로 이동할 수 있는 기능이 있는것같다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Game Kit Controller
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

리지드바디 Velocity 기반


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
미코노트
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

맥북에선 오류가 심함.

아무래도 런타임에 쓸 물건은 아니고, 트레일러등의 제작에 사용할법하다.

내가 본것중에선 가장 프로덕션 레벨에 가까운 아니메 샘플 프로젝트, 연구해볼 필요가 있다.

캐릭터 코는 툭 튀어나오게한다.

캐릭터 얼굴 모델링에서 얼굴의 눈과 얼굴 부분을 판뒤 눈과 혀 등은 안쪽에 넣는다.

Shading Mode 를 Wireframe 으로 하면 끼야아아악 된다.

캐릭터의 만화같은 표정들은 캐릭터 모델링에 딱 붙이지말고 살짝 앞에 띄우는식으로 표시한다


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다이얼로그 시스템
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

여러가지 Saver 는 List 형식으로 