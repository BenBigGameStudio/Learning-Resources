ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
기본 사용 방법
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

컴포넌트의 모든 요소를 다 배울 필요 없다 ! 이것저것 시도해보면서 모르면 그떄 찾아보거나 기능 확장을 고민해라 !

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
유니티 스탠다드 캐릭터 컨트롤러
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

머터리얼을 단순히 Standard 로 교체해주는것만으로 파이프라인 안맞는 문제가 해결되었다.

캐릭터 컨트롤러 기반, 충분히 쓸만하지만 리지드바디 솔루션은 최악이었음.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
인벡터
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

리지드바디 Velocity 기반

Roll 동작은 애니메이터 RootMotion 의 이동위치를 이전 프레임과 비교하여 Velocity 형태로 바꿔서 적용해주는것같음

V Animator Tag Advanced 를 이용하여 애니메이션 NormalziedTime 을 세부적으로 조정 가능

헤드샷 - Spine - Neck - Head 의 VDamageReceiver 를 통해서 구현

래그돌의 지속시간은 vRagdoll - ActivateRagdoll - RagdollStabilizer(2.0f) 에서 찾을 수 있음. Override 해서 2.0f을 변수로 뚫어놔야할듯

LeftArm 과 RightArm 에 무기를 넣어두면 MeleeManager 가 자동으로 참조해서 가져온다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ABC 툴킷
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Topdown, FPS 등등의 탬플릿을 Enable / Disalbe 하는것으로 사용가능

CurrentHealth 는 Ingegration 여부에 따라 다른 값을 리턴, 기본은 ABC Health

Stat 의 Adjust Value 는 값을 +50 하거나 -50 할때 쓰는것, 특정 값으로 설정하려면 SetValue

캐릭터 컨트롤러 + New Input System 기반

GC1 인티그레이션은 큰 쓸모가 없었다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
코기 엔진
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Override 를 통해서 기능을 확장할 수 있었다.

Surface Crawler 와 Corgi Character Controller 를 같이 쓰려면 모든 인스펙터 변수를 0으로 설정해 움직임이 없도록 하면된다.

Grab Carry And Throw 를 위해선 Rigidbody 필요, 캐릭터가 들고있는 오브젝트를 벽위에 놓을경우 끼어버린다. 그래서 최대한 캐릭터 머리위에 위치하게 해야하는듯.

Health 만 있는 캐릭터의 경우 MMFeedback 으로 죽었을때 이것저것 코드를 쉽게 작성할 수 있다.

기본 카메라는 그대로 사용하고, 배경에만 Perspective 를 쓰는것으로 3D 이펙트를 구현할 수 있었다.

Burst Mode 를 이용하여 연속 공격하는 적 구현 가능, 공격은 무기가 하고 무기가 애니메이션을 재생시킨다는 느낌.

Combo Weapon 클래스를 이용해서 콤보 구현가능, 다만 예제에 사용된 무기중 첫번쨰것엔 버그가 있는것같다. 첫번쨰 무기는 순서를 옮기지말자.

특정 Helath 에 대미지를 주려면 Damage 함수 이용

플레이어 리스폰 함수는 Character.RespawnAt 이다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
유니티 2D 게임 킷
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Platform 이펙트를 이용할때 해당 이펙터의 레이어를 플레이와 충돌하지 않도록 바꾸어 구현했다.

겉의 블록에만 타일맵 콜라이더를 심어서 맵을 만드는 방법도 있다. 이떄 맵은 가장자리 블록들이 비어있는걸로 보일 수 있으니 눌러서 확인할것.

Cinemachie 카메라에는 내 캐릭터 위치 / 목표 타겟 위치를 슬라이더로 이동할 수 있는 기능이 있는것같다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
게임 킷 컨트롤러
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

리지드바디 Velocity 기반

어빌리티 휠을 이용해 정말 다양한 능력들을 쓸 수 있었다. 이것들로만 출시해도 무방할정도.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
미코노트
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

맥북에선 오류가 심함.

아무래도 런타임에 쓸 물건은 아니고, 트레일러등의 제작에 사용할법하다.

내가 본것중에선 가장 프로덕션 레벨에 가까운 아니메 샘플 프로젝트, 연구해볼 필요가 있다.

캐릭터 코는 툭 튀어나오게한다.

캐릭터 얼굴 모델링에서 얼굴의 눈과 얼굴 부분을 판뒤 눈과 혀 등은 안쪽에 넣는다.

Shading Mode 를 Wireframe 으로 하면 끼야아아악 된다.

캐릭터의 만화같은 표정들은 캐릭터 모델링에 딱 붙이지말고 살짝 앞에 띄우는식으로 표시한다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다이얼로그 시스템
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

TextTable 을 사용해서 번역 추가 가능

Tools > PixelCrushers > Dialogue System > Dialouge Editor > Templates > Dialogue Entries > + 버튼 누르고 “ Localization “ 항목에서 Title 추가 > Apply Template To Assets

단순히 대화 띄우기 / 대답 받기용으로만 쓰고 이벤트나 조건문등은 분기처리를 해줘도 될듯하다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
비헤비어 트리 디자이너
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

샘플 다운로드 인보이스 넘버 : IN010201852389

Variables 에 Transform 등을 선언한뒤 Task 노드에 사용할 수 있다.

각종 커스텀 비헤비어를 작성하여 사용, 보스전 등에선 "Controlled By Tree" 등의 변수를 통해서 패턴을 결정하면 될듯 ?

Pararell : 동시에 Task 실행



